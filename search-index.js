var searchIndex = {};
searchIndex['rumblebars'] = {"items":[[0,"","rumblebars","[![Build Status](https://travis-ci.org/nicolas-cherel/rumblebars.svg?branch=master)](https://travis-ci.org/nicolas-cherel/rumblebars)",null,null],[3,"Template","","",null,null],[12,"entries","","",0,null],[3,"EvalContext","","Stores partials, helpers and configuration flags",null,null],[12,"compat","","mustache compatibility flag, to enable recursive lookups",1,null],[3,"HelperOptions","","Provides rendering and lookup features to registered helpers",null,null],[12,"context","","current expansion data context",2,null],[12,"condition","","if a parameter was given to helper, holds the result of its truthy/falsy evaluation",2,null],[3,"HTMLSafeWriter","","This writer implementation wraps a Writer and\nwill escape all unsafe html characters",null,null],[4,"ParseError","","",null,null],[13,"UnkownError","","",3,null],[13,"InvalidExpression","","",3,null],[13,"UnmatchedBlock","","",3,null],[13,"UnexpectedBlockClose","","",3,null],[4,"SafeWriting","","Enum that holds either a writer or a wrapped writer, this\nis needed to opt-out filtering easily, so rumblebar uses `SafeWriting` \nto make use of `into_safe()` mostly transparent and stateless, while\nenforcing safe writing through the api.",null,null],[13,"Safe","","",4,null],[13,"Unsafe","","",4,null],[5,"parse","","Parses a handlebars template.",null,{"inputs":[{"name":"str"}],"output":{"name":"parseresult"}}],[5,"eval","","Global function for template evaluation. See [`Template`](struct.Template.html) docs.",null,{"inputs":[{"name":"template"},{"name":"hbdata"},{"name":"write"},{"name":"evalcontext"}],"output":{"name":"hbevalresult"}}],[11,"new","","",0,{"inputs":[{"name":"template"},{"name":"str"}],"output":{"name":"parseresult"}}],[11,"eval_to_string","","",0,{"inputs":[{"name":"template"},{"name":"hbdata"}],"output":{"name":"option"}}],[11,"eval","","",0,{"inputs":[{"name":"template"},{"name":"hbdata"},{"name":"write"},{"name":"evalcontext"}],"output":{"name":"hbevalresult"}}],[11,"default","","",0,{"inputs":[{"name":"template"}],"output":{"name":"template"}}],[11,"from_str","","",0,{"inputs":[{"name":"template"},{"name":"str"}],"output":{"name":"result"}}],[11,"clone","","",3,{"inputs":[{"name":"parseerror"}],"output":{"name":"parseerror"}}],[11,"fmt","","",3,{"inputs":[{"name":"parseerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","regex::re","Compiles a dynamic regular expression. Once compiled, it can be\nused repeatedly to search, split or replace text in a string.",5,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"result"}}],[11,"with_size_limit","","Compiles a dynamic regular expression with the given size limit.",5,{"inputs":[{"name":"regex"},{"name":"usize"},{"name":"str"}],"output":{"name":"result"}}],[11,"is_match","","Returns true if and only if the regex matches the string given.",5,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"bool"}}],[11,"find","","Returns the start and end byte range of the leftmost-first match in\n`text`. If no match exists, then `None` is returned.",5,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"option"}}],[11,"find_iter","","Returns an iterator for each successive non-overlapping match in\n`text`, returning the start and end byte indices with respect to\n`text`.",5,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"findmatches"}}],[11,"captures","","Returns the capture groups corresponding to the leftmost-first\nmatch in `text`. Capture group `0` always corresponds to the entire\nmatch. If no match is found, then `None` is returned.",5,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"option"}}],[11,"captures_iter","","Returns an iterator over all the non-overlapping capture groups matched\nin `text`. This is operationally the same as `find_iter` (except it\nyields information about submatches).",5,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"findcaptures"}}],[11,"split","","Returns an iterator of substrings of `text` delimited by a match\nof the regular expression.\nNamely, each element of the iterator corresponds to text that *isn't*\nmatched by the regular expression.",5,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"regexsplits"}}],[11,"splitn","","Returns an iterator of at most `limit` substrings of `text` delimited\nby a match of the regular expression. (A `limit` of `0` will return no\nsubstrings.)\nNamely, each element of the iterator corresponds to text that *isn't*\nmatched by the regular expression.\nThe remainder of the string that is not split will be the last element\nin the iterator.",5,{"inputs":[{"name":"regex"},{"name":"str"},{"name":"usize"}],"output":{"name":"regexsplitsn"}}],[11,"replace","","Replaces the leftmost-first match with the replacement provided.\nThe replacement can be a regular string (where `$N` and `$name` are\nexpanded to match capture groups) or a function that takes the matches'\n`Captures` and returns the replaced string.",5,{"inputs":[{"name":"regex"},{"name":"str"},{"name":"r"}],"output":{"name":"string"}}],[11,"replace_all","","Replaces all non-overlapping matches in `text` with the\nreplacement provided. This is the same as calling `replacen` with\n`limit` set to `0`.",5,{"inputs":[{"name":"regex"},{"name":"str"},{"name":"r"}],"output":{"name":"string"}}],[11,"replacen","","Replaces at most `limit` non-overlapping matches in `text` with the\nreplacement provided. If `limit` is 0, then all non-overlapping matches\nare replaced.",5,{"inputs":[{"name":"regex"},{"name":"str"},{"name":"usize"},{"name":"r"}],"output":{"name":"string"}}],[11,"as_str","","Returns the original string of this regex.",5,{"inputs":[{"name":"regex"}],"output":{"name":"str"}}],[11,"fmt","regex::backtrack","",6,{"inputs":[{"name":"backtrack"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",7,{"inputs":[{"name":"backmachine"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create new empty state for the backtracking engine.",7,{"inputs":[{"name":"backmachine"}],"output":{"name":"backmachine"}}],[11,"fmt","","",8,{"inputs":[{"name":"job"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",8,{"inputs":[{"name":"job"}],"output":{"name":"job"}}],[11,"exec","","Execute the backtracking matching engine.",6,null],[11,"should_exec","","Returns true iff the given regex and input can be executed by this\nengine with reasonable memory usage.",6,{"inputs":[{"name":"backtrack"},{"name":"program"},{"name":"str"}],"output":{"name":"bool"}}],[11,"cmp","regex::char","",9,{"inputs":[{"name":"char"},{"name":"char"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",9,{"inputs":[{"name":"char"},{"name":"char"}],"output":{"name":"option"}}],[11,"lt","","",9,{"inputs":[{"name":"char"},{"name":"char"}],"output":{"name":"bool"}}],[11,"le","","",9,{"inputs":[{"name":"char"},{"name":"char"}],"output":{"name":"bool"}}],[11,"gt","","",9,{"inputs":[{"name":"char"},{"name":"char"}],"output":{"name":"bool"}}],[11,"ge","","",9,{"inputs":[{"name":"char"},{"name":"char"}],"output":{"name":"bool"}}],[11,"eq","","",9,{"inputs":[{"name":"char"},{"name":"char"}],"output":{"name":"bool"}}],[11,"ne","","",9,{"inputs":[{"name":"char"},{"name":"char"}],"output":{"name":"bool"}}],[11,"hash","","",9,null],[11,"clone","","",9,{"inputs":[{"name":"char"}],"output":{"name":"char"}}],[11,"fmt","","",9,{"inputs":[{"name":"char"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"is_none","","Returns true iff the character is absent.",9,{"inputs":[{"name":"char"}],"output":{"name":"bool"}}],[11,"len_utf8","","Returns the length of the character's UTF-8 encoding.",9,{"inputs":[{"name":"char"}],"output":{"name":"usize"}}],[11,"case_fold","","Returns the simple case folding of this character.",9,{"inputs":[{"name":"char"}],"output":{"name":"char"}}],[11,"is_word_char","","Returns true iff the character is a word character.",9,{"inputs":[{"name":"char"}],"output":{"name":"bool"}}],[11,"as_char","","Converts the character to a real primitive `char`.",9,{"inputs":[{"name":"char"}],"output":{"name":"option"}}],[11,"from","","",9,{"inputs":[{"name":"char"},{"name":"char"}],"output":{"name":"char"}}],[11,"from","","",9,{"inputs":[{"name":"char"},{"name":"option"}],"output":{"name":"char"}}],[11,"eq","","",9,{"inputs":[{"name":"char"},{"name":"char"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",9,{"inputs":[{"name":"char"},{"name":"char"}],"output":{"name":"option"}}],[11,"new","regex::compile","Creates a new compiler that limits the size of the regex program\nto the size given (in bytes).",10,{"inputs":[{"name":"compiler"},{"name":"usize"}],"output":{"name":"compiler"}}],[11,"compile","","Compiles the given regex AST into a tuple of a sequence of\ninstructions and a sequence of capture groups, optionally named.",10,{"inputs":[{"name":"compiler"},{"name":"expr"}],"output":{"name":"result"}}],[11,"fmt","regex::input","",11,{"inputs":[{"name":"inputat"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",11,{"inputs":[{"name":"inputat"}],"output":{"name":"inputat"}}],[11,"is_beginning","","Returns true iff this position is at the beginning of the input.",11,{"inputs":[{"name":"inputat"}],"output":{"name":"bool"}}],[11,"char","","Returns the character at this position.",11,{"inputs":[{"name":"inputat"}],"output":{"name":"char"}}],[11,"len","","Returns the UTF-8 width of the character at this position.",11,{"inputs":[{"name":"inputat"}],"output":{"name":"usize"}}],[11,"pos","","Returns the byte offset of this position.",11,{"inputs":[{"name":"inputat"}],"output":{"name":"usize"}}],[11,"next_pos","","Returns the byte offset of the next position in the input.",11,{"inputs":[{"name":"inputat"}],"output":{"name":"usize"}}],[11,"fmt","","",12,{"inputs":[{"name":"charinput"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Return a new character input reader for the given string.",12,{"inputs":[{"name":"charinput"},{"name":"str"}],"output":{"name":"charinput"}}],[11,"deref","","",12,{"inputs":[{"name":"charinput"}],"output":{"name":"str"}}],[11,"at","","",12,{"inputs":[{"name":"charinput"},{"name":"usize"}],"output":{"name":"inputat"}}],[11,"previous_at","","",12,{"inputs":[{"name":"charinput"},{"name":"usize"}],"output":{"name":"inputat"}}],[11,"prefix_at","","",12,{"inputs":[{"name":"charinput"},{"name":"prefix"},{"name":"inputat"}],"output":{"name":"option"}}],[11,"new","regex::pool","Create a new pool.",13,{"inputs":[{"name":"pool"},{"name":"box"}],"output":{"name":"pool"}}],[11,"get","","Request a resource from the pool.",13,{"inputs":[{"name":"pool"}],"output":{"name":"t"}}],[11,"put","","Add a resource to the pool.",13,null],[11,"fmt","","",13,{"inputs":[{"name":"pool"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","regex::prefix","",14,{"inputs":[{"name":"prefix"}],"output":{"name":"prefix"}}],[11,"new","","Create a new prefix matching machine.",14,{"inputs":[{"name":"prefix"},{"name":"vec"}],"output":{"name":"prefix"}}],[11,"find","","Find the position of a prefix in `haystack` if it exists.",14,{"inputs":[{"name":"prefix"},{"name":"str"}],"output":{"name":"option"}}],[11,"is_empty","","Returns true iff this prefix is empty.",14,{"inputs":[{"name":"prefix"}],"output":{"name":"bool"}}],[11,"len","","Returns the number of prefixes in this machine.",14,{"inputs":[{"name":"prefix"}],"output":{"name":"usize"}}],[11,"preserves_priority","","Returns true iff the prefix match preserves priority.",14,{"inputs":[{"name":"prefix"}],"output":{"name":"bool"}}],[11,"fmt","","",14,{"inputs":[{"name":"prefix"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","regex::program","",15,{"inputs":[{"name":"inst"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",15,{"inputs":[{"name":"inst"}],"output":{"name":"inst"}}],[11,"fmt","","",16,{"inputs":[{"name":"onechar"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",16,{"inputs":[{"name":"onechar"}],"output":{"name":"onechar"}}],[11,"fmt","","",17,{"inputs":[{"name":"charranges"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",17,{"inputs":[{"name":"charranges"}],"output":{"name":"charranges"}}],[11,"eq","","",18,{"inputs":[{"name":"lookinst"},{"name":"lookinst"}],"output":{"name":"bool"}}],[11,"ne","","",18,{"inputs":[{"name":"lookinst"},{"name":"lookinst"}],"output":{"name":"bool"}}],[11,"fmt","","",18,{"inputs":[{"name":"lookinst"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",18,{"inputs":[{"name":"lookinst"}],"output":{"name":"lookinst"}}],[11,"matches","","Tests whether the given input character matches this instruction.",16,{"inputs":[{"name":"onechar"},{"name":"char"}],"output":{"name":"bool"}}],[11,"any","","Emits a range specifically for the `.` expression.",17,{"inputs":[{"name":"charranges"}],"output":{"name":"charranges"}}],[11,"any_nonl","","Emits a range specifically for the `(?s).` expression.",17,{"inputs":[{"name":"charranges"}],"output":{"name":"charranges"}}],[11,"from_class","","Emits a range from the AST character class.",17,{"inputs":[{"name":"charranges"},{"name":"charclass"}],"output":{"name":"charranges"}}],[11,"matches","","Tests whether the given input character matches this instruction.",17,{"inputs":[{"name":"charranges"},{"name":"char"}],"output":{"name":"option"}}],[11,"matches","","Tests whether the pair of characters matches this zero-width\ninstruction.",18,{"inputs":[{"name":"lookinst"},{"name":"char"},{"name":"char"}],"output":{"name":"bool"}}],[11,"fmt","","",19,{"inputs":[{"name":"matchengine"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",19,{"inputs":[{"name":"matchengine"}],"output":{"name":"matchengine"}}],[11,"fmt","","",20,{"inputs":[{"name":"program"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Compiles a Regex.",20,{"inputs":[{"name":"program"},{"name":"option"},{"name":"usize"},{"name":"str"}],"output":{"name":"result"}}],[11,"exec","","Executes a compiled regex program.",20,null],[11,"num_captures","","Returns the total number of capture groups in the regular expression.\nThis includes the zeroth capture.",20,{"inputs":[{"name":"program"}],"output":{"name":"usize"}}],[11,"alloc_captures","","Allocate new capture groups.",20,{"inputs":[{"name":"program"}],"output":{"name":"vec"}}],[11,"find_prefixes","","Find and store a prefix machine for the current program.",20,null],[11,"clone","","",20,{"inputs":[{"name":"program"}],"output":{"name":"program"}}],[11,"fmt","regex::nfa","",21,{"inputs":[{"name":"nfa"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"exec","","Execute the NFA matching engine.",21,null],[11,"fmt","","",22,{"inputs":[{"name":"nfathreads"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",23,{"inputs":[{"name":"threads"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",24,{"inputs":[{"name":"thread"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",24,{"inputs":[{"name":"thread"}],"output":{"name":"thread"}}],[11,"new","","Create new empty state for the NFA engine.",22,{"inputs":[{"name":"nfathreads"},{"name":"usize"},{"name":"usize"}],"output":{"name":"nfathreads"}}],[11,"fmt","regex::re","",25,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",25,{"inputs":[{"name":"error"}],"output":{"name":"str"}}],[11,"cause","","",25,{"inputs":[{"name":"error"}],"output":{"name":"option"}}],[11,"fmt","","",25,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",25,{"inputs":[{"name":"error"},{"name":"error"}],"output":{"name":"error"}}],[11,"clone","","",5,{"inputs":[{"name":"regex"}],"output":{"name":"regex"}}],[11,"clone","","",26,{"inputs":[{"name":"exnative"}],"output":{"name":"exnative"}}],[11,"fmt","","Shows the original regular expression.",5,{"inputs":[{"name":"regex"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","Shows the original regular expression.",5,{"inputs":[{"name":"regex"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",5,{"inputs":[{"name":"regex"},{"name":"regex"}],"output":{"name":"bool"}}],[11,"from_str","","Attempts to parse a string into a regular expression",5,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"result"}}],[11,"next","","",27,{"inputs":[{"name":"namesiter"}],"output":{"name":"option"}}],[11,"reg_replace","","",28,{"inputs":[{"name":"noexpand"},{"name":"captures"}],"output":{"name":"cow"}}],[11,"no_expand","","",28,{"inputs":[{"name":"noexpand"}],"output":{"name":"option"}}],[11,"next","","",29,{"inputs":[{"name":"regexsplits"}],"output":{"name":"option"}}],[11,"next","","",30,{"inputs":[{"name":"regexsplitsn"}],"output":{"name":"option"}}],[11,"pos","","Returns the start and end positions of the Nth capture group.\nReturns `None` if `i` is not a valid capture group or if the capture\ngroup did not match anything.\nThe positions returned are *always* byte indices with respect to the\noriginal string matched.",31,{"inputs":[{"name":"captures"},{"name":"usize"}],"output":{"name":"option"}}],[11,"at","","Returns the matched string for the capture group `i`.  If `i` isn't\na valid capture group or didn't match anything, then `None` is\nreturned.",31,{"inputs":[{"name":"captures"},{"name":"usize"}],"output":{"name":"option"}}],[11,"name","","Returns the matched string for the capture group named `name`.  If\n`name` isn't a valid capture group or didn't match anything, then\n`None` is returned.",31,{"inputs":[{"name":"captures"},{"name":"str"}],"output":{"name":"option"}}],[11,"iter","","Creates an iterator of all the capture groups in order of appearance\nin the regular expression.",31,{"inputs":[{"name":"captures"}],"output":{"name":"subcaptures"}}],[11,"iter_pos","","Creates an iterator of all the capture group positions in order of\nappearance in the regular expression. Positions are byte indices\nin terms of the original string matched.",31,{"inputs":[{"name":"captures"}],"output":{"name":"subcapturespos"}}],[11,"iter_named","","Creates an iterator of all named groups as an tuple with the group\nname and the value. The iterator returns these values in arbitrary\norder.",31,{"inputs":[{"name":"captures"}],"output":{"name":"subcapturesnamed"}}],[11,"expand","","Expands all instances of `$name` in `text` to the corresponding capture\ngroup `name`.",31,{"inputs":[{"name":"captures"},{"name":"str"}],"output":{"name":"string"}}],[11,"len","","Returns the number of captured groups.",31,{"inputs":[{"name":"captures"}],"output":{"name":"usize"}}],[11,"is_empty","","Returns true if and only if there are no captured groups.",31,{"inputs":[{"name":"captures"}],"output":{"name":"bool"}}],[11,"next","","",32,{"inputs":[{"name":"subcaptures"}],"output":{"name":"option"}}],[11,"next","","",33,{"inputs":[{"name":"subcapturespos"}],"output":{"name":"option"}}],[11,"next","","",34,{"inputs":[{"name":"subcapturesnamed"}],"output":{"name":"option"}}],[11,"next","","",35,{"inputs":[{"name":"findcaptures"}],"output":{"name":"option"}}],[11,"next","","",36,{"inputs":[{"name":"findmatches"}],"output":{"name":"option"}}],[11,"into_unsafe","rumblebars","disclose the unsafe writer without touching self",4,{"inputs":[{"name":"safewriting"}],"output":{"name":"safewriting"}}],[11,"with_html_safe_writer","","quick way to get a SafeWriter that escapes html",4,{"inputs":[{"name":"safewriting"},{"name":"write"},{"name":"fn"}],"output":{"name":"hbevalresult"}}],[11,"write","","",4,null],[11,"flush","","",4,{"inputs":[{"name":"safewriting"}],"output":{"name":"result"}}],[11,"new","","",37,{"inputs":[{"name":"htmlsafewriter"},{"name":"write"}],"output":{"name":"htmlsafewriter"}}],[11,"write","","",37,null],[11,"flush","","",37,{"inputs":[{"name":"htmlsafewriter"}],"output":{"name":"result"}}],[11,"writer","","",37,{"inputs":[{"name":"htmlsafewriter"}],"output":{"name":"write"}}],[11,"typed_node","rustc_serialize::json","",38,{"inputs":[{"name":"json"}],"output":{"name":"hbnodetype"}}],[11,"write_value","","",38,{"inputs":[{"name":"json"},{"name":"safewriting"}],"output":{"name":"hbevalresult"}}],[11,"get_key","","",38,{"inputs":[{"name":"json"},{"name":"str"}],"output":{"name":"option"}}],[11,"as_bool","","",38,{"inputs":[{"name":"json"}],"output":{"name":"bool"}}],[11,"values","","",38,{"inputs":[{"name":"json"}],"output":{"name":"hbvaluesiter"}}],[11,"keys","","",38,{"inputs":[{"name":"json"}],"output":{"name":"hbkeysiter"}}],[11,"iter","","",38,{"inputs":[{"name":"json"}],"output":{"name":"hbiter"}}],[11,"write_value","collections::string","",39,{"inputs":[{"name":"string"},{"name":"safewriting"}],"output":{"name":"hbevalresult"}}],[11,"typed_node","","",39,{"inputs":[{"name":"string"}],"output":{"name":"hbnodetype"}}],[11,"as_bool","","",39,{"inputs":[{"name":"string"}],"output":{"name":"bool"}}],[11,"get_key","","",39,{"inputs":[{"name":"string"},{"name":"str"}],"output":{"name":"option"}}],[11,"keys","","",39,{"inputs":[{"name":"string"}],"output":{"name":"hbkeysiter"}}],[11,"values","","",39,{"inputs":[{"name":"string"}],"output":{"name":"hbvaluesiter"}}],[11,"iter","","",39,{"inputs":[{"name":"string"}],"output":{"name":"hbiter"}}],[11,"option_by_name","rumblebars","data passed as options (eg `{{helper option=\"one\" option=name.val}}`)",2,{"inputs":[{"name":"helperoptions"},{"name":"string"}],"output":{"name":"option"}}],[11,"lookup","","fetch data at given path",2,{"inputs":[{"name":"helperoptions"},{"name":"hbdata"}],"output":{"name":"option"}}],[11,"lookup_with_context","","same as lookup, but with custom context instead of current one (this)",2,{"inputs":[{"name":"helperoptions"},{"name":"hbdata"},{"name":"hbdata"}],"output":{"name":"option"}}],[11,"render_fn","","for a helper with a block, such as `{{if}}{{/if}}`, renders block content",2,{"inputs":[{"name":"helperoptions"},{"name":"safewriting"}],"output":{"name":"hbevalresult"}}],[11,"render_fn_with_context","","same as render_fn, but with custom context",2,{"inputs":[{"name":"helperoptions"},{"name":"hbdata"},{"name":"safewriting"}],"output":{"name":"hbevalresult"}}],[11,"inverse","","for a helpers with blocks, such as `{{if}}{{else}}{{/if}}`, renders the `{{else}}` block content",2,{"inputs":[{"name":"helperoptions"},{"name":"safewriting"}],"output":{"name":"hbevalresult"}}],[11,"inverse_with_context","","same as inverse, but with custom context",2,{"inputs":[{"name":"helperoptions"},{"name":"hbdata"},{"name":"safewriting"}],"output":{"name":"hbevalresult"}}],[11,"render_fn_with_context_and_globals","","allow block rendering with custom context and custom globals (data available with @key)",2,{"inputs":[{"name":"helperoptions"},{"name":"hbdata"},{"name":"safewriting"},{"name":"hashmap"}],"output":{"name":"hbevalresult"}}],[11,"render_fn_with_globals","","",2,{"inputs":[{"name":"helperoptions"},{"name":"safewriting"},{"name":"hashmap"}],"output":{"name":"hbevalresult"}}],[11,"default","","",1,{"inputs":[{"name":"evalcontext"}],"output":{"name":"evalcontext"}}],[11,"new","","just return a default EvalContext without having to declare use of std:default",1,{"inputs":[{"name":"evalcontext"}],"output":{"name":"evalcontext"}}],[11,"partials","","Map of registered partials",1,{"inputs":[{"name":"evalcontext"}],"output":{"name":"hashmap"}}],[11,"register_partial","","adds a partial in the evaluation context",1,{"inputs":[{"name":"evalcontext"},{"name":"string"},{"name":"template"}],"output":null}],[11,"partial_with_name","","fetch a registered partial by name",1,{"inputs":[{"name":"evalcontext"},{"name":"str"}],"output":{"name":"option"}}],[11,"register_helper","","adds a helper to the evaluation context",1,{"inputs":[{"name":"evalcontext"},{"name":"string"},{"name":"helperfunction"}],"output":null}],[11,"helper_with_name","","fetch a registered helper by name",1,{"inputs":[{"name":"evalcontext"},{"name":"str"}],"output":{"name":"option"}}],[11,"has_helper_with_name","","true if a helper with given name is registered",1,{"inputs":[{"name":"evalcontext"},{"name":"str"}],"output":{"name":"bool"}}],[6,"HBIter","","",null,null],[6,"HBKeysIter","","",null,null],[6,"HBValuesIter","","",null,null],[6,"HBEvalResult","","",null,null],[6,"HelperOptionsByName","","",null,null],[8,"HBData","","",null,null],[10,"write_value","","",40,{"inputs":[{"name":"hbdata"},{"name":"safewriting"}],"output":{"name":"hbevalresult"}}],[10,"typed_node","","",40,{"inputs":[{"name":"hbdata"}],"output":{"name":"hbnodetype"}}],[10,"get_key","","",40,{"inputs":[{"name":"hbdata"},{"name":"str"}],"output":{"name":"option"}}],[10,"as_bool","","",40,{"inputs":[{"name":"hbdata"}],"output":{"name":"bool"}}],[10,"keys","","",40,{"inputs":[{"name":"hbdata"}],"output":{"name":"hbkeysiter"}}],[10,"values","","",40,{"inputs":[{"name":"hbdata"}],"output":{"name":"hbvaluesiter"}}],[10,"iter","","",40,{"inputs":[{"name":"hbdata"}],"output":{"name":"hbiter"}}]],"paths":[[3,"Template"],[3,"EvalContext"],[3,"HelperOptions"],[4,"ParseError"],[4,"SafeWriting"],[4,"Regex"],[3,"Backtrack"],[3,"BackMachine"],[4,"Job"],[3,"Char"],[3,"Compiler"],[3,"InputAt"],[3,"CharInput"],[3,"Pool"],[4,"Prefix"],[4,"Inst"],[3,"OneChar"],[3,"CharRanges"],[4,"LookInst"],[4,"MatchEngine"],[3,"Program"],[3,"Nfa"],[3,"NfaThreads"],[3,"Threads"],[3,"Thread"],[4,"Error"],[3,"ExNative"],[4,"NamesIter"],[3,"NoExpand"],[3,"RegexSplits"],[3,"RegexSplitsN"],[3,"Captures"],[3,"SubCaptures"],[3,"SubCapturesPos"],[3,"SubCapturesNamed"],[3,"FindCaptures"],[3,"FindMatches"],[3,"HTMLSafeWriter"],[4,"Json"],[3,"String"],[8,"HBData"]]};
initSearch(searchIndex);
